
# ðŸ“‘ Student Handout: GitLab CI/CD â€“ Job Execution, Artifacts & Caching

---

## **Part 1 â€“ Controlling Job Execution Order**

### 1. Why Control Job Order?

* Ensures **correct sequencing** â†’ `build â†’ test â†’ deploy`.
* Prevents deploying untested code.
* Allows **parallel execution** while respecting dependencies.
* Supports **cleanup, notifications, and audits** at the right points.
* Enables **failure management** so non-critical jobs donâ€™t block the pipeline.

---

### 2. Using `needs:` for Explicit Dependencies

By default, GitLab runs jobs **stage by stage**.

* `needs:` allows jobs to **depend on specific jobs** across stages.

âœ… Example:

```yaml
job1:
  stage: build
  script:
    - echo "Build step"

job2:
  stage: test
  script:
    - echo "Test step"
  needs: [job1]
```

* Here `job2` runs only after `job1`, regardless of stage order.

---

### 3. Controlling Run Conditions (`when:`)

* **`on_success` (default):** Run only if all previous jobs succeed.
* **`on_failure`:** Run only if any previous job fails (good for notifications).
* **`always`:** Run regardless of outcome (cleanup, logging).
* **`manual`:** Requires user approval (e.g., production deploy).
* **`delayed`:** Runs after a set delay.
* **`never`:** Skip execution unless overridden by rules.

âœ… Example â€“ Always run notification:

```yaml
build:
  script: exit 1   # fails

notify:
  script: echo "Notify stakeholders"
  when: always
```

---

### 4. Handling Failures with `allow_failure`

* Lets jobs fail **without failing the whole pipeline**.
* Useful for non-critical checks, experiments, or quality gates.

âœ… Example:

```yaml
test_job:
  script: exit 1
  allow_failure: true

deploy:
  script: echo "Deploying..."
```

---

### 5. Advanced: Combining with `rules:`

* Rules evaluate **conditions (branch, variables, schedule)**.
* `when:` inside rules overrides global job config.

âœ… Example â€“ Run audit logs only on schedule:

```yaml
audit:
  script: echo "Audit logs"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: always
    - when: never
```

---

---

## **Part 2 â€“ Artifacts & Caching**

### 1. What Are Artifacts and Cache?

* **Artifacts:**

  * Pass files between jobs/stages **within the same pipeline run**.
  * Example: compiled binaries, reports, docs.
* **Cache:**

  * Reuse files across multiple pipeline runs.
  * Example: `node_modules/`, `vendor/`, `.m2/` (Maven dependencies).

---

### 2. Using Artifacts

Artifacts help **share build outputs** with later stages.

âœ… Example:

```yaml
build:
  stage: build
  script:
    - make build
  artifacts:
    paths:
      - build/
    expire_in: 1 week

test:
  stage: test
  script:
    - test -d build/
    - ./run_tests.sh
```

* `paths:` â€“ files/folders to save.
* `expire_in:` â€“ retention period (default: 30 days).

---

### 3. Using Cache

Cache speeds up builds by **reusing dependencies**.

âœ… Example â€“ Cache NPM dependencies:

```yaml
install-deps:
  stage: install
  script:
    - npm install
  cache:
    key: $CI_COMMIT_REF_SLUG-node
    paths:
      - node_modules/
    policy: pull-push

build-app:
  stage: build
  script:
    - npm run build
  cache:
    key: $CI_COMMIT_REF_SLUG-node
    paths:
      - node_modules/
    policy: pull
```

* `key:` â€“ identifies the cache (branch, job, or hash).
* `policy:` â€“

  * `pull-push` (default): restore & update cache.
  * `pull`: restore only.
  * `push`: update only.

---

### 4. Key Differences: Artifacts vs Cache

| Aspect        | Artifacts                   | Cache                           |
| ------------- | --------------------------- | ------------------------------- |
| Retention     | 30 days (default)           | Indefinite (until cleared)      |
| Scope         | Same pipeline               | Across pipelines on same runner |
| Purpose       | Build outputs, reports      | Dependencies, libraries         |
| Accessibility | Downloadable from GitLab UI | Not downloadable                |

---

### 5. Hands-On Example â€“ Pass Artifacts Across Stages

```yaml
build:
  stage: build
  script:
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 1 week

test:
  stage: test
  script:
    - npm test
    - ls dist/

deploy:
  stage: deploy
  script:
    - cp -r dist/* /var/www/html/
  environment: production
```

---

### 6. Best Practices

* **Use the right tool:**

  * Artifacts â†’ build outputs.
  * Cache â†’ dependencies.
* **Cache keys:** Use lock files (`package-lock.json`) for consistency.
* **Avoid caching large build outputs** â†’ use artifacts instead.
* **Monitor performance:** Track pipeline times with/without caching.
* **Expire artifacts smartly** â†’ donâ€™t retain large files unnecessarily.

---

## âœ… Key Takeaways

* Control job execution order with `needs:`, `when:`, and `allow_failure`.
* Use artifacts to **pass build outputs** between jobs.
* Use cache to **speed up builds** across pipelines.
* Combine best practices for **efficient & secure CI/CD pipelines**.

